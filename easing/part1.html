<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Fullscreen Canvas Starter</title>
    <style>
      /* Page reset */
      html, body {
        height: 100%;
        margin: 0;
        overflow: hidden; /* no scrollbars */
        background: #0b0f14;
        color: #dbe4ee;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      }

      /* The app root fills the viewport */
      #app {
        position: fixed;
        inset: 0; /* top:0 right:0 bottom:0 left:0 */
        display: grid;
        grid-template-rows: auto 1fr; /* header, canvas area, footer */
      }

      /* Canvas container fills the remaining space */
      .stage {
        position: relative;
        min-height: 0; /* allow child to size to container without overflow */
      }

      canvas#stageCanvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block; /* removes tiny gaps in some browsers */
        outline: none;
        cursor: crosshair;
        /* Do not set the canvas width/height attributes in CSS for pixels. We set them in JS for device pixels. */
      }

      .hud {
        position: absolute;
        top: 12px;
        right: 12px;
        padding: 6px 8px;
        background: rgba(0, 0, 0, 0.35);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        font: 12px/1.2 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      }

      a { color: #8ab4f8; text-decoration: none; }
      a:hover { text-decoration: underline; }
    </style>
  </head>
  <body>
    <div id="app">
      <div id="header">
        <select id="easing_function"></select>
        <input id="duration" type="number" value="1000" min="100" max="10000" step="100">
      </div>
      <main class="stage">
        <canvas id="stageCanvas" aria-label="Interactive canvas"></canvas>
        <div class="hud" id="hud">0 × 0 @1x</div>
      </main>
    </div>

    <script type="module">
      import { easing } from './easing.js';

      // Canvas sizing with device pixel ratio for crisp rendering
      const easing_function = document.getElementById('easing_function');
      const duration = document.getElementById('duration');
      const canvas = document.getElementById('stageCanvas');
      const hud = document.getElementById('hud');
      const ctx = canvas.getContext('2d');

      function canvasPos(e) {
        const rect = canvas.getBoundingClientRect();
        return { x: e.clientX - rect.left, y: e.clientY - rect.top };
      }

      function drawCircle(x, y, radius, fillColor, strokeColor, strokeWidth) {
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fillStyle = fillColor;
        ctx.fill();
        ctx.lineWidth = strokeWidth;
        ctx.strokeStyle = strokeColor;
        ctx.stroke();
      }

      let dpr = 1;

      function fitCanvasToViewport() {
        dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));

        const { width: cssW, height: cssH } = canvas.getBoundingClientRect();

        // Set internal pixel size to DPR-scaled values
        const pxW = Math.round(cssW * dpr);
        const pxH = Math.round(cssH * dpr);

        if (canvas.width !== pxW) canvas.width = pxW;
        if (canvas.height !== pxH) canvas.height = pxH;

        // Reset transform then scale to map 1 canvas unit to 1 CSS pixel
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);

        hud.textContent = `${Math.round(cssW)} × ${Math.round(cssH)} @${dpr}x`;

        drawDemo();
      }

      // Demo draw. Replace with your own scene logic.
      function drawDemo() {
        const { width, height } = canvas.getBoundingClientRect();

        // Clear
        ctx.clearRect(0, 0, width, height);

        // Background grid
        const grid = 32;
        ctx.globalAlpha = 0.25;
        ctx.beginPath();
        for (let x = 0; x <= width; x += grid) {
          ctx.moveTo(x + 0.5, 0);
          ctx.lineTo(x + 0.5, height);
        }
        for (let y = 0; y <= height; y += grid) {
          ctx.moveTo(0, y + 0.5);
          ctx.lineTo(width, y + 0.5);
        }
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#2a3947';
        ctx.stroke();
        ctx.globalAlpha = 1;
      }

      // Resize handling. Use both resize and a ResizeObserver for safety.
      const ro = new ResizeObserver(() => fitCanvasToViewport());
      ro.observe(document.querySelector('.stage'));
      window.addEventListener('resize', fitCanvasToViewport);

      // Handle DPR changes, for example when moving between screens
      matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`).addEventListener('change', fitCanvasToViewport, { once: false });

      function noop() {}

      // Pointer state
      let isMoving = false;
      let pos = { x: 0, y: 0 };
      let move = noop;

      canvas.addEventListener('pointerdown', e => {
        const startPos = { ...pos };
        const targetPos = canvasPos(e);
        const startTime = Date.now();
        const animDuration = parseInt(duration.value, 10);

        move = () => {
          let tRatio = (Date.now() - startTime) / animDuration;
          if (tRatio > 1) {
            tRatio = 1;
            move = noop;
          }
          pos.x = easing[easing_function.value](tRatio, startPos.x, targetPos.x - startPos.x, 1);
          pos.y = easing[easing_function.value](tRatio, startPos.y, targetPos.y - startPos.y, 1);
        }
      });

      // Render loop
      function render() {
        drawDemo();

        move();
        drawCircle(pos.x, pos.y, 50, '#8ab4f8', '#ffffff', 4);

        requestAnimationFrame(render);
      }

      fitCanvasToViewport();

      function run() {
        easing_function.replaceChildren(
          ... Object.entries(easing).map(([key, func]) => {
            const option = document.createElement('option');
            option.textContent = key;
            option.value = key;
            return option;
          })
        );

        render();
      }

      run();
    </script>
  </body>
</html>
